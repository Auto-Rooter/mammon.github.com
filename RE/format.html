<html>
<head><title>File and Protocol Formats</title></head>
<body bgcolor=A0A0A0 link=FFFFFF text=4040A0 vlink=0000A0>
<!-- schema: code editor. Blue w/yellow + white fg -->
<center><h1><font color=FFFFFF>R.E. HQ</font></h1></center>
<center><h3>The science of reverse engineering</h3></center>
<HR>
	  <!--  +++++++++++++++++++++++++++++++++++++++++++++++++Abstract -->
	  <center><font color=FFFFFF>File and Protocol Formats</font></center>
	  <i><font size=-1>
	  Analyzing blocks of data from a file or communication protocol to 
	  determine the format used, usually in order to extract meaningful 
	  data, or to implement a parser for the file/protocol.
	  </font></i>
	  <P><BR>
	  <!--  +++++++++++++++++++++++++++++++++++++++++++++++Background -->
	  <font color=000080>
     In general, the formats of files and network or device communication 
     protocols are of little concern; the majority of those in use have 
     been documented in <A href="http://www.rfc.net">RFCs</a>, or at programming resource sites
     such as <a href="http://www.wotsit.org">Wotsit</a>.<P>
     On occasion , though, a vendor or a legacy application will use a proprietary 
     format, the documentation of which is lost, purchased only under prohibitive 
     licensing, or generally unavailable short of a spot of the old B&E. In these 
     cases, one must reverse engineer the format of the file or protocol in order 
     to interface with and/or replace it.<P>
     Parsing unknown formats is primarily an excercise in identifying and classifying 
     patterns within a block of data. A file, for example, might begin with an 
     identifying <i>magic</i> sequence of bytes, followed by information on the 
     contents of the file; a network protocol might require the sending of a receipt 
     message [for instance, the IP <i>ACK</i> packet] for every successful transmission. <P>
     Encryption and compression -- two sides of the same coin in the computer world -- 
     complicate matters by rendering source data unrecognizable. This can be as much a 
     boon as an obstacle; generally speaking, only the data portions of a format will 
     be encrypted, while magic numbers and content descriptions [e.g. file headers] will 
     remain unencrypted. The file loader or protocol partner must have a means of knowing 
     whether it is receiving valid input, or simply garbage. By comparing different files 
     or protocol sequences generated by the same product, the encrypted or compressed 
     data will appear as sequences of randomly patterned and sized data amidst more or less 
     static formatting information.<P>
     </font>
     <P><BR>
	  <!--  +++++++++++++++++++++++++++++++++++++++++++++++++++Papers -->
	  <P><BR>
	  <!--  +++++++++++++++++++++++++++++++++++++++++++++Case Studies -->
	  <p>
	  <HR>
	  <center><a href="index.html">R.E. HQ</a></center>
</body>
</html>
